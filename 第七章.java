import object.*;

public class 第七章 {


    /*
     * 第七章：复用类
     * 	·复用代码是java众多引人注目的功能之一
     *	  ·第一种：(组合语法)在新类中引入现有类的代码
     *	  ·第二种：继承语法
     *	  ·第三种：代理
     *
     *	·组合语法
     *	  ·toString():每一个非基本类型的对象都有一个toString()方法
     *	· 继承语法
     */
    Detergent d;//继承语法看这里

    /*
     * 	·初始化基类
     * 	  ·当你创建一个导出类对象时，该对象还包含一个基类的子对象(之所以称为基类的子对象，是因为与基本的对象还有一点区别，创建导出类时会创建基类的子对象会调用基类的构造器)，
     * 		这个基类的子对象与你直接创建的对象是一样的，二者的区别是后者是外部的(显示写出来的)，前者是基类的子对象被包装在导出类对象的内部
     * 	  ·对基类子对象的正确初始化：在构造器中调用基类的构造器来完成初始化
     */
    Cartoon cartoon;//初始化一个导出类点进去看

    /*
     * 	·初始化带有参数的构造器
     */
    Chess chess;//初始化创建带有参数的导出类


    /*
     * 	·代理
     * 	  · java并没有提供对它的直接支持，这是继承与组合的中庸之道
     * 	  ·将一个成员对象置于所要构造的类中(就像组合)，但是同时该类也拥有该成员对象的所有方法(与继承相似，比继承具有更大的灵活性)
     */
    SpaceShipDelegation spaceShipDelegation;//代理类看里面


    /* ·结合使用组合和继承
     * 	·既有组合又有代理
     *
     * ·名称屏蔽
     * 	·如果java的基类拥有某个已被多次重载的方法的名称，那么在导出类 中重载一个方法(方法名一样，参数不一样)，并不会屏蔽其在基类中的任何版本。
     * 	    因此，无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作的。
     */
    Hide hide;//名称屏蔽:基类与重载剪不断的关系

    /*
     * ·在组合与继承之间选择
     * 	·组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做。
     *	  ·组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形，一般情况下应该使域成为private
     */

    /*
     * ·protected关键字
     * 	·将某些事物尽可能对这个世界隐藏起来，但是允许导出类的成员去访问它们
     * 	·访问范围：
     * 	  ·导出类
     * 	  ·同一个包的其他类(即包访问权限)
     * 	·尽管可以创建protected域，但是最好的方式还是将域保持为private，
     */


    /*
     *	·继承
     *	  ·"为新类提供方法"并不是继承技术中最重要的方面，最重要的方面是用来表现新类和基类之间的关系。这种类型可以用"新类是现有类的一种类型"概括。(更多的是表现出一种层次和包含的关系)
     *		一个例子：
     *		·假设有一个称为Instrument的代表乐器的基类，和一个称为Wind的导出类。由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送
     *		如果Instrument类具有一个play()方法，那么Wind乐器也将同样具备。这意味着我们可以准确的说Wind对象也是一种类型的Instrument。
     *	  ·向上转型：
     *		由导出类转型成基类，在继承图是向上移动的。由于向上转型是从一个  较专用类型  向  较通用类型  转换，所以总是安全的(但是有可能出现导出类方法的丢失)。
     *		也就是说导出类是基类的一个超集，它可能比基类含有更多的方法。但它必须至少具备基类中所含有的方法。
     */
    Wind wind;//向上转型




    /*
     * 	·fianl关键字
     * 	  ·根据上下文环境，java关键字final的含义存在着细微的区别，但通常它指的是"这是无法改变的"
     * 	  ·不想做改变可能出于两种理由:设计或效率
     */


    /*
     * 	·可能使用到final的三种情况：数据，方法，类
     *
     * 	  ·final数据
     * 		·一个永不改变的编译时常量
     * 		  ·编译器对于常量值是告知一块数据是恒定不变的，这减轻了一些运行时的负担。这类常量必须是基本数据类型，在进行定义时必须赋值。
     * 		  ·一个既是static又是fianl的域只占据一段不能改变的存储空间
     * 		·一个在运行时被初始化值，而你不希望它被改变
     * 		  ·对象类型使用fianl。fianl使引用恒定不变，一旦一个fianl的 引用  被初始化指向一个对象，就无法改变该引用指向另一个对象。但是被指引的对象本身可以修改
     */
    FinalData finalData;//final数据

    /*
     * 		·空白final
     * 		  ·java允许生成"空白final"，所谓空白final是指被声明为final但又未给定初值的域，虽然可以不用立即给定，但是编译器都确保final在使用前必须被初始化(就是在使用前被赋值)。
     * 			(两个地方进行赋值)必须在  域的定义处  或者每个  构造器中  用表达式对final进行赋值，这正是final域在使用前总被初始化的原因所在。
     */
    BlankFinal blankFinal;//空白final，其实并不空白

    /*
     * 		·final参数
     * 		  ·java允许在参数中声明参数为final。这意味着你无法在方法中改变参数引用所指向的对象，你可以读参数，但无法修改。
     */
    FinalArguments finalArguments;

    /*	  ·final方法
     * 		·使用final方法的原因有两个。一个是把方法锁定，以防任何继承类修改它的含义。一个是确保在继承中使方法行为保持不变，并且不会被覆盖(重写)
     * 		  ·只有在想要明确禁止覆盖时，才将方法设置为final
     * 		·final和private关键字
     * 		  ·类中的所有private方法都隐式地指定为final的。由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰词，但是没有任何的意义。
     */
    FinalOverridingIllusion finalOverridingIllusion;


    /*
     * 	  ·final类
     * 		·当将一个类加上final(在class前面加)，就表明你不打算继承该类，而且也不允许别人这样做。
     * 		  ·这样做是处于两种考虑，一是出于考虑，你对该类的设计永不需要任何的改动，或者出于安全的考虑，你不希望它有子类。
     * 		·无论类是不是被定义为final，相同的规则都适用于定义final域(就是不能被更改，参考上面final数据的规则)。
     * 			然而，由于final类禁止继承，所以final类中的所有方法都隐式指定为final的，因为无法覆盖他们。可以给方法添加final，但是没有任何的意义。
     */
    Jursaaic jursaaic;//final类


    /*
     * ·初始化及类的加载
     * 	·一般来说，"类的代码是在初次使用时才加载"，这通常加载是指发生于创建类的第一个对象时，当访问static域或者是static方法时也会被加载。
     * 	  ·构造器也是static方法，只是没有显式的写出来。更准确的说，类是在其任何static成员被访问时才加载。
     */

    /*
     * ·继承与初始化
     * 	·了解包括继承在内的初始化全过程，以对所发生的一切有个全局性的把握。
     */
    Beetle beetle;//一个有  继承其他类  的类 是如何初始化的

    /*
     * 练习
     */
    public void test1() {
        new ObjectH();
    }

    public void test2() {
        new Amphibian();
    }

    public void test3() {
        new FinalAndStatic();
    }//final与final+static

    public void test4() {
        new EmptyFinal(new Objc());
    }//空的final

    public void test5() {
        new ObjectI();
    }
}
