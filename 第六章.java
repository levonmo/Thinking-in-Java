import object.ConnectionManager;

public class 第六章 {

    /*
     * 第六章：访问权限控制
     * 		(注意：访问控制权限控制专注于  类库创建者  和  使用该库的外部使用者  之间的关系，这种关系也是一种通信方式)
     * 	·包:库的单元
     * 		当你编写一个java文件时候，此文件通常被称为编译单元。每个编译单元后面都要一个.java后缀。而编译单元后面可以有一个public类，该类的名称必须与文件名相同
     *   	每个编译单元只能有一个public类，否则编译器就不会接受。如果编译单元还有别的类，那么它不能是public类，那么在包之外是无法看见这些类的，而且他们主要是为public类提供服务的。
     *
     *   	如果想要将这些编译单元从属与同一个组群，就可以使用package。
     *   	如果使用package，它必须是文件(除注释之外)的第一行程序代码，例如:package access;(包的命名规则全部使用小写字母)
     *   	 会 把package名称分解为你机器目录上的一个文件夹 ，当java程序运行并且需要加载.class文件的时候，java程序就根据目录找到.class文件并加载它。
     *
     *    ·java解析器的运行过程如下：
     *   	·首先，你要设置环境变量CLASSPATH(类文件一定要放在这得子目录下面 )，例如:CLASSPATH=.;D:\JAVA\LIB;C:DOC\JavaT(环境变量可以设置多个)
     *   	·然后可以把类文件放在 CLASSPATH中 的任何目录之下，(就是你这类文件的绝对路径前面一段一定是 CLASSPATH 中配置有的)
     *   	·当编译器碰到mo库(假如存在这个库)的import语句时，就会在 CLASSPATH 所指定的目录中寻找，查找指定的目录中是否存在子目录(com/mo)，然后就可以选择的导入要使用的类了。
     *
     *   	·冲突：如果导入了  两个不同的库中  有名字相同 的类，就要使用指定类名:java.util.Vector v = new java.util.Vector();
     *
     * 	  ·定制工具类(静态地导入包)
     * 		·用来创建自己的工具库来减少或消除重复的程序代码。在使用这种类时，可以用一个更具有可读性的静态import语句来导入。
     * 		  import static com.mo.Print.*;(表示可以使用Print类中的所有方法)
     *
     * 	·java的访问修饰符
     * 	  ·如果不提供修饰符，默认是包访问权限，意味着当前包中的所有其他类对那个成员都有访问权限。但对于这个包之外，所有类对这个成员杀死private。
     * 	  ·类控制着自己成员的访问权限。
     * 		·成员的访问修饰符为public：无论是谁，在哪里，都可以访问该成员
     * 		·不加修饰符是赋予成员的包访问权限(同一个包内的其他类可见)，其他包的不可见
     * 		·继承的类，可以访问父类的protected成员(private成员不行)
     *	  ·默认包：没有给自己设定任何包的名称，java会将这样的类自动归为默认包，并给他们都赋予包访问权限(在默认包内)。
     *
     *	  ·private：除了本身的类，其他所有都不能访问。(就算是父类的private成员也不能访问)
     *	  ·protected：继承访问权限，子类可以访问父类protected的成员。protected成员还具有包访问权限(相同包内的其他类可以访问protected元素)
     *
     *	·类的访问权限
     *	  ·每个编译单元，只能有一个public(也可以没有，这样这个类就是包访问权限)，public类的类名要与编译单元名一样
     *	  ·类不能是private或protected。所以对于类访问权限，仅有两个选择：包访问权限和public(什么都不写就是包访问权限)。
     *		如果不希望其他人对该类拥有访问权限，可以将所有的构造器都指定为private，从而阻止任何人创建对象。
     *		可以在该类的static成员内部创建对象。例如：
     */
    object.Lunch Lunch;//点进去


    /*
     * 练习
     */
    ConnectionManager connectionManager;//点进去看看
}
