import object.*;

public class 第五章 {

    /*
     * 第五章：初始化与清理
     * 	·构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空明显不同(new表达式确实返回了新建对象的引用，但构造器本身并没有返回值)
     * 	·方法重载：方法名相同，形参不同的 方法(构造器也是方法)。
     * 	·如果传入的参数类型 小于 声明的参数类型(精度大的参数类型就大double>float>int)，传人的参数类型就会被提升(对实际的数值是没有影响的)
     * 		char类型略有不同，如果没法找到char类型的参数方法，就会把传人的char直接提升为int(假如你把一个char类型传人，而刚好也有接受int参数的方法)
     * 	·如果传人的实际参数大于声明的，编译器就会出现一个错误。(例如传人的参数是double类型，但是方法要接受的是int类型的，这个时候就会报错)，必须进行类型显式配置类型转换
     * 	·不能以返回值区分重载方法
     */


    public static void main(String[] args) {
        acceptFloat();


        /*
         * this关键字
         * 	·this只能方法的内部使用，表示对"调用方法的那个对象"的引用。
         */



        /*
         * 清理:终结处理和垃圾回收
         * 	·垃圾回收器只知道释放那些经过由new分配的内存。(但是有一些内存是垃圾回收器无法清理的，例如清理一个int)。
         * 		假设你的对象(并非使用new)获得了一块"特殊"的内存区域。
         * 		由于你的垃圾回收器只知道回收new分配的内存，所以它不知道该如何释放该对象的这块"特殊"内存。
         * 		为了应对这种情况，java允许在类中定义一个名为finalize()的方法。它的工作原理是这样的:
         * 		一旦垃圾回收器准备好释放对象占用的空间，将首先调用finalize()，并在下一次垃圾回收时做一些重要的工作。
         *  ·垃圾回收只与内存有关
         *  	使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说(尤其是finalize方法)，它们也必须同内存及其回收有关。
         *  ·finalize()的用途何在?
         *  	是不是意味这对象中含有其他的对象(当垃圾回收器工作的时候，就没有回收到对象里面的特殊对象)，finalize()就应该明确释放那些特殊的对象?
         *  	答案是否定的。
         *  	无论对象是怎么创建的，垃圾回收器都会负责释放对象占据的所有内存。(所以上面的担心是多余的)
         *  	这就对finalize()的需求限制到一种情况：即是通过某种创建对象方式  以外的方式  为  对象分配内存 的情况 。但是java中一切都是对象，这种情况是怎么回事。
         *  	这种情况主要发生在使用"本地方法"的情况下，本地方法是一种在java中调用非java代码的方式。本地方法主支持c/c++。在非java代码中，也许会调用c的malloc函数来分配内存空间，
         *  	而且如果没有调用free()函数，则内存就得不到释放，从而造成内存泄漏。因为free()是c/c++中函数，所以需要在finalize()中用本地方法调用它。
         *  ·无论是"垃圾回收"还是"终结"，都不能保证一定会发生。如果java虚拟机没有面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存。(一直监控垃圾，和垃圾回收需要大量的成本)
         *  ·终结条件
         *  	通常，不能指望finalize()帮你进行"清理"工作，必须创建其他的清理工作。在垃圾回收对象时，会调用一次finalize()方法(也许不会被调用)，所以可以在垃圾回收前判断一下，是否可以安全回收了。
         *  	当你对某个对象不在感兴趣了--也就是可以被清理了，这个对象应该处于某种状态，使它占用的内存可以被安全的释放。
         *  	例如，要是对象打开了一个文件，在垃圾回收时，程序员应该关闭这个文件。 对象是否可以安全的被回收(也就是对象存在很难看见的缺陷)。这时就可以使用finalize()来发现这种缺陷--尽管它并不是
         *  	总被调用(只有内存耗尽才会被调用，或是手动)。
         *  	一个例子:示范了finalize()可能的使用方式
         */
        checkIn();

        /*
         * 垃圾回收器如何工作
         * 	·在以前的编程语言中，在  堆  上分配对象的代价十分高昂，因此读者自然会觉得java中所有的对象(基本类型除外)都在   堆  上分配的方式也非常高昂。
         * 	  然而，垃圾回收器对于提高对象的创建速度，却有明显的效果。听起来很奇怪--存储空间的释放竟然会影响存储空间的分配，但这确实是某些java虚拟机的工作方式。
         * 	 这就意味着，java从  堆  分配速度，可以和其他语言从 堆栈 上分配空间的速度相媲美。
         *
         * 	·可以把C++里的 堆 想象成一个院子，里面每个对象都负责 管理自己的地盘，一段时间后，对象可能被销毁，但地盘必须加以重用(这里要消耗成本)。
         * 	  在java堆中，堆的实现是截然不同:它更像一个传送带，每分配一个新的对象，它就往前移动一格。这就意味着对象存储空间分配速度非常快
         *   java的 堆指针 只是简单的移动到没分配的区域，其效率比得上C++在  堆栈 上分配空间的效率。
         *
         * 	·其实，java中的堆并不完全像传送带那样的工作，会导致频繁的内存页面调度，会影响性能，当创建的对象足够多的时候，最终内存耗尽。
         * 	  其中的秘密就是不会像真的传送带那样，指针一直的往后移动，在于垃圾回收器的介入。当它工作时，将一边回收空间，一边将 堆 中的对象紧凑排列，这样指针可以更靠近传送带的开始处(就不会一直往后指)
         *
         * 	·垃圾回收器的依据思想是：
         * 	   对任何"活"的对象，一定能最终追溯到其存活在  堆栈  或 静态存储区 之中的引用。这个引用链可能会穿过数个对象层次。
         * 	   从 堆栈 和 静态存储区 遍历所有的引用，就能找到"活"的对象。对于发现的每个引用，跟踪它引用的对象，然后找到此对象包含的所有引用(如果存在的话)。
         * 	   如此反复进行，直到"存在于 堆 和 静态存储区 中的所有引用"所形成的网络全部被访问到为止(所有引用都能找到对象)。就是根据 堆栈 中的引用将 对应的对象全部查找出来。
         *
         * 	  在这种方式下，java采取一种 "自适应"的垃圾回收技术 。至于如何找到存活的对象，取决与java虚拟机的实现(上面也是一种方式)。
         * 	 有一种做法名为 "停止-复制" 。显然这意味着，先把当前运行的程序暂停下来 (所以它不属于后台回收模式)，然后把活的对象(取决于java虚拟机实现，有很多种方式)从当前 堆 复制到另一个 堆 中。
         * 	 没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以新堆保持紧密排列。
         *
         * 	 当把对象从一处搬到另一处时，所有引用的指向必须修正。对于这种所谓的"复制式回收器"而言，效率会降低。这里有两个原因
         * 	  ·第一个:有两个堆，然后在这两个堆之间来回倒腾，需要很多时间。
         * 	  ·第二个问题在于复制，程序进入稳定状态之后，可能只会产生少量的垃圾，复制器仍然将所有的内存从一处复制到另一处，这要很大的成本以及浪费。
         * 		为了避免这种情况，java虚拟机会进行检查：要是没有垃圾产生，就会转换到另一种工作模式("自适应")。这种模式称为"标记-清扫"，速度很慢，但当只产生少量垃圾时甚至没有垃圾产生，它的速度就很快了。
         *	  ·"标记-清扫"所依据的思路同样是从  堆栈 和  静态存储区 出发，遍历所有的引用，找出与之对应的 "活"的对象，就会给这个对象一个标记，这个过程不会回收任何对象。
         *		只有全部标记工作完成的时候，清理工作才进行，没有被标记的对象将被释放，不会发生任何的复制操作。所以剩下的  堆  是不连续的。(不像上面的"停止-复制"模式，等到的 堆 是连续的)
         * 	  ·
         *
         * 	·内存分配以较大的"块"为单位，如果对象较大就会，它就会占用单独的块。严格来收，"停止-复制"要求在释放旧有对象之前，必须先把所有存活对象从 旧堆  复制到 新堆，这就导致大量的复制行为。
         * 	  每个块都用相应的代数来记录它是否还存活。通常，如果块在某处被引用，其代数会增加。垃圾回收装置会定期进行清理动作--大型对象仍然不会被复制(只是其代数增加)，内含小型对象的那些块则被复制并整理。
         * 	  java虚拟机进行监视，如果所有对象都很稳定，回收效率低的话，就会切换到"标记-清扫"模式，如果碎片很多就会切换到"停止-复制"模式。这就是"自适应"技术。
         *
         * 	·java虚拟机中有很多附加的技术用以提升速度。尤其是与加速器操作有关，被称为"即时"编译技术。这种技术可以将程序全部或部分翻译为本地机器码(这本是java虚拟机的工作)，程序运行速度因此而提升。
         */


        /*
         *	成员初始化
         *	  ·构造器初始化:
         *		·初始化顺序:在构造参数调用之前，所有的变量(实例变量)都被初始化了，变量定义的先后顺序决定了初始化的顺序(不包含局部变量)，即使变量定义散步与方法定义之间，
         *				 它们仍然会在任何方法(包含构造器)被调用之前得到初始化。
         */
        OrderOfIn orderOfIn;//构造器初始化可以点进去看
        /*
         * 		·静态数据的初始化(static关键字)：  无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，只能作用于域。
         * 			 如果一个域是静态的基本类型域，且没有初始化，那就会获得基本类型的初值，如果是对象，初值是null
         * 			静态初始化只有在必要的时刻才会进行，如果不创建该类型的对象，或者是通过类名访问，那么静态的变量就永远不会被初始化，当被初始化了，静态对象不会再次被初始化
         * 			初始化的顺序是先"静态"后"非静态"
         *
         */
        StaticWord staticWord;//点进去
        /*
         *  	·显式的静态初始化：静态块。也是首次创建所在的对象的时候初始化，只初始化一次
         *  		static{
         *  			int i = 1;
         *  		}
         *  	·非静态实例化初始化：看起来与  静态初始化字句  差不多，只不过是少了static关键字。这种语法对于支持"匿名内部类"的初始化时必须的。
         *  		{
         *  			int i = 1;
         *  		}
         */


        /*
         * 可变参数列表
         * 	·在SE5.0之前，要想使用可变参数类型是  要创建以Object数组为参数的方法，并像下面这样调用
         * 	·注意:可变参数要放在参数列表中的最后一个
         * 		例如:h(int a,Integer... args)
         * 		而不能 h(Integer... args,int a)
         */
        printArray(new String[]{});
        f();


        /*
         * 	·有了可变参数，就再也不用显示地编写数组语法，当你指定参数时，实际上会为你创建一个数组。你获得的仍然是一个数组
         */
        varargType();


        /*
         * 	·可变参数列表使得重载过程变得复杂
         * 		在每一个中情况，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确的方法
         */
        testH();


        /*
         * 枚举类型
         *	·在SE5.0添加了一个看似很小的特征，即关键字enum关键字(方便，安全)
         *	·尽管enum看起来像一种新的数据类型，但是这个关键字只是为enum生成对应的类是让编译器产生了某些编译器行为。事实上，enum确实是一个类，并且具有自己的方法。
         */
        enumType();


        /*
         * enum有一个特别实用的特征，即它可以在switch语句内使用
         * 	·由于switch是要在有限的可能值集合中进行选择，因此它与enum正是绝佳组合
         *	·在SE5.0之前，你需要花费大量的工作才能保证与枚举等价的安全可用性。
         */
        enumType2();

    }

    private static void enumType2() {
        switch (Spiciness.MEDIUM) {
            case MEDIUM:
                System.out.println("MEDIUM");
                break;
            default:
                System.out.println("default");
                break;
        }
    }

    private static void enumType() {
        Spiciness s = Spiciness.MEDIUM;//如何定义一个枚举类型可以点进去看
        System.out.println(s.toString());
        System.out.println(s.ordinal());//编译器还会ordinal()方法，用来表示某个enum常量的声明顺序
        /*
         * 还可以遍历进行遍历
         */
        for (Spiciness sp : Spiciness.values()) {
            System.out.println(sp + ",ordinal" + sp.ordinal());
        }
    }

    private static void testH() {
        h('a','b');
        h(1);
//		h();
        /*
         * 在每一次。编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法
         * 	但是在使用0参数调用h()时，编译器就无法知道使用的是哪一个方法了，编译器就会出现一个错误
         */
    }

    private static void varargType() {
        new VarargType();//点进去可以看可变参数的语法，以及相关的信息
        new AutoboxingVarargs();
    }

    private static void f() {
        printArray(new Object[]{1,2,3});//这里想要  可变参数  ，就将参数封装为一个数组，再将数组传入
    }

    /*
     * 可变参数列表
     * 	·在SE5.0之前，要想使用可变参数类型是  要创建以Object数组为参数的方法，并像下面这样调用
     * 	·注意:可变参数要放在参数列表中的最后一个
     * 		例如:h(int a,Integer... args)
     * 		而不能 h(Integer... args,int a)
     */
    private static void printArray(Object[] args) {
        for (Object ob : args) {
            System.out.println(ob);
        }
    }

    private static void checkIn() {
        //点击去的是一个例子，执行main方法即可
        new Book(true);
    }

    private static void acceptFloat() {
        //如果一个接受一个参数的方法，可以将精度比double低的类型传进去,里面会进行自动进行类型转换(例如将int = 4传进去会转换为4.0)
        int a = 4;
        acceptDouble(a);
        //但是不接受一个比自己精度低的参数，例如将接收int参数的，将一个double类型的传进去是不能的。因为这样是有可能丢失信息的
        double b = 4;
//		acceptInt(b);//例如这样编译器就会出错
    }

    private static void acceptDouble(double a){System.out.println(a);}

    private static void acceptInt(int a){}

    private static void h(Character... args){
        for (Character c : args) {
            System.out.print(c);
        }
        System.out.println(args.getClass());
    }

   private static void h(Long... args){
        for (Long i : args) {
            System.out.print(i);
        }
        System.out.println(args.getClass());
    }

   private static void h(Integer... args){
        for (Integer i : args) {
            System.out.print(i);
        }
        System.out.println(args.getClass());
    }
}
